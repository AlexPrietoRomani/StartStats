% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_significance_groups.R
\name{plot_significance_groups}
\alias{plot_significance_groups}
\title{Visualización de Grupos de Significancia Post-Hoc}
\usage{
plot_significance_groups(
  data,
  facet_var = NULL,
  reorder_x = TRUE,
  desc = TRUE,
  x_label = "",
  rotation_x_ticks = 90,
  y_label = "",
  title = "",
  text_offset = 0.05,
  y_lim_percent = 0.1,
  plot_width = 7,
  plot_height = 5,
  ggsave = FALSE
)
}
\arguments{
\item{data}{Un tibble o data.frame. \strong{Debe ser la salida directa de la función
\code{generate_groups}}. Se espera que contenga las columnas \code{interaccion} (factor/carácter),
\code{means} (numérica), y \code{groups} (carácter).}

\item{facet_var}{Un string opcional. El nombre de una variable en el \code{data}
que se utilizará para crear facetas (sub-gráficos). Si es \code{NULL} (por defecto),
no se crearán facetas. Si la columna \code{interaccion} ya es un factor combinado
(ej. "Genotipo:Tratamiento"), este argumento puede ser útil si deseas
desglosar la visualización por uno de los componentes de la interacción.
\strong{Nota:} Para usar \code{facet_var}, la columna \code{interaccion} en \code{data}
probablemente necesitará ser el resultado de \code{forcats::fct_reorder} o
similar, con el factor combinado. Si la \code{interaccion} ya es una cadena
combinada (ej. "G1:T1"), \code{facet_var} no podrá usarse directamente para desagruparla
a menos que se cree una nueva columna con esa información.}

\item{reorder_x}{Un valor lógico (\code{TRUE}/\code{FALSE}). Si \code{TRUE} (por defecto),
las categorías en el eje X (\code{interaccion}) se reordenarán según los valores
de \code{means}.}

\item{desc}{Un valor lógico (\code{TRUE}/\code{FALSE}). Si \code{TRUE} (por defecto),
el reordenamiento se hará de mayor a menor. Si \code{FALSE}, de menor a mayor.
Solo aplica si \code{reorder_x = TRUE}.}

\item{x_label}{Un string. Etiqueta para el eje X. Por defecto es una cadena vacía.}

\item{rotation_x_ticks}{Un número. Grados de rotación para las etiquetas del eje X.
Útil para evitar solapamiento. Por defecto es \code{90}.}

\item{y_label}{Un string. Etiqueta para el eje Y. Por defecto es una cadena vacía.}

\item{title}{Un string. Título principal del gráfico. Por defecto es una cadena vacía.}

\item{text_offset}{Un valor numérico. Factor de desplazamiento vertical para
las letras de significancia sobre las barras. Un valor de \code{0.05} (5\%) significa
que el texto estará un 5\% por encima de la altura de la barra.}

\item{y_lim_percent}{Un valor numérico. Porcentaje adicional para el límite
superior del eje Y, calculado como \code{max_y * (1 + y_lim_percent)}. Útil para
asegurar espacio para las etiquetas y evitar que se corten. Un valor de \code{0.1}
(10\% más) es el valor por defecto.}

\item{plot_width}{Un número. Ancho del gráfico en pulgadas. Por defecto es \code{7}.}

\item{plot_height}{Un número. Alto del gráfico en pulgadas. Por defecto es \code{5}.}
}
\value{
Un objeto \code{ggplot2} que representa el gráfico de barras con las
letras de significancia. Este objeto puede ser impreso directamente o
personalizado aún más usando la sintaxis de \code{ggplot2}.
}
\description{
\code{plot_significance_groups} crea un gráfico de barras a partir del resultado
de la función \code{generate_groups}, mostrando las medias (o medianas) de los
grupos y sus letras de significancia estadística. La función está diseñada
para ser rápida y didáctica, abstraiendo la complejidad de \code{ggplot2} para el usuario.
Permite una fácil visualización de los resultados de pruebas post-hoc como Tukey,
Games-Howell, Duncan, Dunn o Dunnett.
}
\details{
La función asume que el \code{data} de entrada es el resultado de \code{generate_groups},
lo que significa que ya contiene las columnas \code{interaccion}, \code{means}, y \code{groups}.
Utiliza \code{geom_col_pattern} para un estilo visual atractivo y \code{viridis} para
la escala de colores, lo que mejora la accesibilidad.
}
\examples{
# Asegúrate de haber ejecutado la función generate_groups primero
# y tener los paquetes necesarios cargados:
# library(dplyr); library(ggplot2); library(ggpattern); library(viridis); library(forcats)

# Crear datos de ejemplo (los mismos usados en generate_groups)
set.seed(123)
df_ejemplo <- data.frame(
  genotipo = rep(c("G1", "G2", "G3", "G4", "Control"), each = 20),
  rendimiento = c(rnorm(20, 50, 5), rnorm(20, 55, 5), rnorm(20, 45, 5), rnorm(20, 70, 5), rnorm(20, 52, 5)),
  rendimiento_log = c(log(rnorm(20, 50, 5)), log(rnorm(20, 55, 5)), log(rnorm(20, 45, 5)), log(rnorm(20, 70, 5)), log(rnorm(20, 52, 5))),
  sabor_score = sample(1:5, 100, replace = TRUE, prob = c(0.1, 0.2, 0.3, 0.2, 0.2))
)
# Introducir algunos outliers y NAs para probar robustez
df_ejemplo$rendimiento[c(5, 25, 45, 85)] <- c(10, 100, NA, 15)
df_ejemplo$sabor_score[c(10, 30, 90)] <- NA

# Ejemplo de uso:
# 1. Generar los grupos de significancia (usando la función generate_groups de tu librería)
grupos_rendimiento <- generate_groups(
  data = df_ejemplo,
  var_original = "rendimiento",
  formula_interaccion = "genotipo",
  method = "tukey",
  verbose = FALSE # Para no llenar la consola con mensajes de generate_groups
)

# 2. Generar el gráfico con la nueva función
\dontrun{
plot_significance_groups(
  data = grupos_rendimiento,
  title = "Rendimiento por Genotipo con Grupos de Tukey",
  y_label = "Rendimiento Promedio (kg/ha)",
  x_label = "Genotipo"
)
# Guardar el gráfico con tamaño específico
# ggsave("rendimiento_genotipo.png", last_plot(), width = 8, height = 6, units = "in")
}

# Ejemplo con faceta (si tu interacción tuviera otra variable)
# Nota: Este ejemplo asume una estructura de datos más compleja,
# donde 'interaccion' en 'grupos_rendimiento_facet' sería de la forma "G1:T1",
# y 'facet_var' se extraería de alguna manera. Por la simplicidad de la
# salida de generate_groups (que es solo una columna 'interaccion'),
# el uso de facet_var para desagrupar interacciones combinadas no es directo
# sin un procesamiento adicional en el dataframe de entrada.
# Sin embargo, si 'interaccion' es simplemente 'genotipo' y quieres
# facetar por otra variable que está en 'df_ejemplo' pero no en 'grupos_rendimiento',
# necesitarías hacer un join primero.

# Aquí un ejemplo adaptado que usa la salida de generate_groups directamente
# y asume que 'interaccion' ya es lo que queremos en el eje X.
# Si quisieras facetas, la salida de generate_groups debería estar preparada
# para ello (ej. generate_groups genera "genotipo:campana" y luego agregas una
# columna "campana_extraida" para el facet).

# Considera este ejemplo si quieres facetas por algo YA PRESENTE EN df_ejemplo
# Y lo agregas a grupos_rendimiento
df_ejemplo_con_campana <- df_ejemplo \%>\%
  dplyr::mutate(campana = rep(c("C1", "C2"), 50)) # Añadir una variable de campaña

# Generar grupos para la interacción genotipo:campana
grupos_interaccion <- generate_groups(
  data = df_ejemplo_con_campana,
  var_original = "rendimiento",
  formula_interaccion = "~ genotipo * campana", # Interacción en la fórmula
  method = "tukey",
  verbose = FALSE
)

# Para poder usar facet_var, necesitamos que la columna de faceta exista en grupos_interaccion.
# Esto requiere un poco de procesamiento en la salida de generate_groups
grupos_con_facet <- grupos_interaccion \%>\%
  tidyr::separate(interaccion, into = c("genotipo_facet", "campana_facet"), sep = ":") \%>\%
  dplyr::mutate(genotipo_facet = as.factor(genotipo_facet), campana_facet = as.factor(campana_facet))

\dontrun{
plot_significance_groups(
  data = grupos_con_facet,
  facet_var = "campana_facet", # Ahora podemos facetar
  title = "Rendimiento por Genotipo y Campaña con Grupos de Tukey",
  y_label = "Rendimiento Promedio (kg/ha)",
  x_label = "Genotipo",
  rotation_x_ticks = 45 # Menos rotación para facetas si los nombres son cortos
)
}

}
